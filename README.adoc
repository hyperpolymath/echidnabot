image:https://img.shields.io/badge/License-PMPL--1.0-blue.svg[License: PMPL-1.0,link="https://github.com/hyperpolymath/palimpsest-license"]
image:https://img.shields.io/github/license/hyperpolymath/echidnabot[License]
image:https://img.shields.io/github/v/release/hyperpolymath/echidnabot?include_prereleases[GitHub Release]

// SPDX-License-Identifier: PMPL-1.0-or-later

= echidnabot: Proof-Aware CI Bot

:toc: macro
:toclevels: 3
:icons: font
:source-highlighter: pygments

_Formal verification CI bot that orchestrates ECHIDNA for automatic theorem proof verification on every push._

toc::[]

== Overview

**echidnabot** bridges code platforms (GitHub, GitLab, Bitbucket) and the ECHIDNA theorem proving platform. Every push, every PRâ€”proofs get verified automatically and results appear in your CI checks.

=== The Problem

You're writing formally verified softwareâ€”proofs in Coq, Lean, Agda, or Isabelle. But your CI pipeline doesn't understand proofs:

* Tests pass, but **proofs are broken**
* PRs merge with **unverified theorems**
* No one notices until a dependent build fails
* Manual verification is **slow and error-prone**

=== The Solution

[source]
----
  GitHub/GitLab/Bitbucket
           â”‚
           â”‚ webhook (push/PR)
           â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚    echidnabot     â”‚  â—„â”€â”€ Rust, Tokio, Axum
   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
   â”‚  â”‚ Dispatcher  â”‚â”€â”€â”¼â”€â”€â–º ECHIDNA Core (Agda, Coq, Lean, Z3...)
   â”‚  â”‚ Scheduler   â”‚  â”‚
   â”‚  â”‚ GraphQL API â”‚  â”‚
   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ Check Runs / Comments
           â–¼
       âœ“ Proof verified
       âœ— Proof failed (line 42: goal not discharged)
----

== Features

=== Multi-Prover Support

[cols="1,1,2"]
|===
|Tier |Provers |Status

|**Tier 1** |Coq, Lean 4, Agda, Isabelle/HOL, Z3, CVC5 |Ready
|**Tier 2** |Metamath, HOL Light, Mizar |MVP
|**Tier 3** |PVS, ACL2, HOL4 |Planned
|===

=== Multi-Platform Integration

* **GitHub** â€” Check Runs, PR comments, issues (full support)
* **GitLab** â€” Commit statuses, MR notes, issues (full support)
* **Bitbucket** â€” Build statuses, PR comments, issues (full support)
* **Codeberg** â€” Planned

All platforms use a unified adapter interface for consistent behavior.

=== Bot Modes

* **Verifier** â€” Silent pass/fail on proof files
* **Advisor** â€” Suggestions on failing proofs
* **Consultant** â€” Answer questions about proof state
* **Regulator** â€” Block merges on proof failures

=== ML-Powered Tactic Suggestions

When proofs fail, echidnabot can suggest tactics via ECHIDNA's Julia ML backend:

[source]
----
âŒ Proof failed at theorem `list_append_assoc`
   Goal: âˆ€ xs ys zs, xs ++ (ys ++ zs) = (xs ++ ys) ++ zs

ğŸ’¡ Suggested tactics:
   â€¢ Try `induction xs` to break down the list structure
   â€¢ Consider `rewrite app_assoc` if available
   â€¢ Check if `simpl` simplifies the goal
----

== Installation

=== Prerequisites

* Rust 1.75+
* PostgreSQL (for job queue and results storage)
* Access to ECHIDNA instance (or run locally)

=== From Source

[source,bash]
----
git clone https://github.com/hyperpolymath/echidnabot.git
cd echidnabot
cargo build --release
----

=== Database Setup

[source,bash]
----
# Create database
createdb echidnabot

# Run migrations
sqlx database create
sqlx migrate run
----

== Usage

=== Server Mode (Webhook Receiver)

Run echidnabot as a webhook server for your forge:

[source,bash]
----
# Set environment variables
export DATABASE_URL=postgres://localhost/echidnabot
export GITHUB_APP_ID=123456
export GITHUB_PRIVATE_KEY_PATH=/path/to/key.pem
export GITHUB_WEBHOOK_SECRET=your-secret
export ECHIDNA_URL=http://localhost:8080

# Start the server
echidnabot serve --port 3000
----

==== API Endpoints

* `GET /` - Health check
* `GET /health` - Detailed health status
* `POST /webhook` - GitHub webhook receiver
* `POST /webhook/gitlab` - GitLab webhook receiver
* `POST /webhook/bitbucket` - Bitbucket webhook receiver
* `POST /graphql` - GraphQL API for queries and mutations

=== GraphQL API

Query verification job status:

[source,graphql]
----
query {
  verificationJob(id: "job-123") {
    id
    status
    prover
    repository
    commitSha
    results {
      theorem
      status
      message
    }
  }
}
----

Submit a verification job:

[source,graphql]
----
mutation {
  submitVerification(
    repository: "owner/repo"
    commitSha: "abc123"
    prover: LEAN4
    files: ["src/Theorems.lean"]
  ) {
    id
    status
  }
}
----

=== CLI Mode (Manual Verification)

Verify proofs locally without webhooks:

[source,bash]
----
# Verify a specific proof file
echidnabot verify --prover lean4 --file src/Theorems.lean

# Verify all proof files in a directory
echidnabot verify --prover coq --dir theories/

# Check verification job status
echidnabot status --job-id abc123
----

== Configuration

=== Environment Variables

[source,bash]
----
# Database
DATABASE_URL=postgres://localhost/echidnabot

# GitHub App
GITHUB_APP_ID=123456
GITHUB_PRIVATE_KEY_PATH=/path/to/private-key.pem
GITHUB_WEBHOOK_SECRET=webhook-secret-here

# GitLab
GITLAB_TOKEN=glpat-your-token-here

# Bitbucket
BITBUCKET_TOKEN=your-app-password-here

# ECHIDNA
ECHIDNA_URL=http://localhost:8080
ECHIDNA_API_KEY=optional-api-key

# Server
PORT=3000
RUST_LOG=info
----

=== Prover Configuration

Create `echidna-config.toml`:

[source,toml]
----
[provers.coq]
enabled = true
timeout = 300  # seconds
memory_limit = "4GB"

[provers.lean4]
enabled = true
timeout = 600
memory_limit = "8GB"

[provers.isabelle]
enabled = true
timeout = 900
memory_limit = "16GB"
----

== Multi-Forge Adapter System

echidnabot uses a unified adapter pattern for all platforms:

=== Platform Adapters

[source,rust]
----
pub trait PlatformAdapter {
    async fn clone_repo(&self, repo: &RepoId, commit: &str) -> Result<PathBuf>;
    async fn create_check_run(&self, repo: &RepoId, check: CheckRun) -> Result<CheckRunId>;
    async fn update_check_run(&self, id: CheckRunId, status: CheckStatus) -> Result<()>;
    async fn create_comment(&self, repo: &RepoId, pr: PrId, body: &str) -> Result<CommentId>;
    async fn create_issue(&self, repo: &RepoId, issue: NewIssue) -> Result<IssueId>;
    async fn get_default_branch(&self, repo: &RepoId) -> Result<String>;
}
----

All platforms (GitHub, GitLab, Bitbucket) implement this interface for consistent behavior.

=== Adding a New Platform

1. Implement `PlatformAdapter` trait in `src/adapters/yourplatform.rs`
2. Add platform-specific API client and authentication
3. Map platform events to echidnabot's unified event model
4. Add webhook route in `src/main.rs`

== Integration with Gitbot Fleet

echidnabot is part of the https://github.com/hyperpolymath/gitbot-fleet[Gitbot Fleet]:

* **https://github.com/hyperpolymath/rhodibot[rhodibot]** - RSR structural compliance
* **https://github.com/hyperpolymath/seambot[seambot]** - Architectural seam hygiene
* **echidnabot** (this bot) - Formal verification orchestration
* **https://github.com/hyperpolymath/finishingbot[finishingbot]** - Release readiness
* **glambot** - Presentation quality

Bots coordinate through a shared context layer managed by https://github.com/hyperpolymath/hypatia[hypatia].

== CI Integration

=== GitHub Actions

[source,yaml]
----
# .github/workflows/verify-proofs.yml
# SPDX-License-Identifier: PMPL-1.0-or-later
name: Verify Proofs
on: [push, pull_request]
permissions: read-all

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4
      - name: Verify with echidnabot
        run: |
          curl -X POST https://echidna.example.com/verify \
            -H "Content-Type: application/json" \
            -d '{"repository": "${{ github.repository }}", "sha": "${{ github.sha }}"}'
----

=== GitLab CI

[source,yaml]
----
verify-proofs:
  stage: test
  script:
    - curl -X POST https://echidna.example.com/verify
           -H "Content-Type: application/json"
           -d '{"repository": "$CI_PROJECT_PATH", "sha": "$CI_COMMIT_SHA"}'
----

== Development

=== Prerequisites

* Rust 1.75+
* PostgreSQL 14+
* sqlx-cli (`cargo install sqlx-cli`)

=== Building

[source,bash]
----
cargo build
----

=== Testing

[source,bash]
----
# Run all tests
cargo test

# Run with test database
DATABASE_URL=postgres://localhost/echidnabot_test cargo test
----

=== Database Migrations

[source,bash]
----
# Create new migration
sqlx migrate add my_migration

# Run migrations
sqlx migrate run

# Revert last migration
sqlx migrate revert
----

=== Architecture

Key modules:

* `src/main.rs` - Server entry point, webhook routes
* `src/graphql/` - GraphQL schema and resolvers
* `src/adapters/` - Multi-platform abstraction layer
** `src/adapters/github.rs` - GitHub API client
** `src/adapters/gitlab.rs` - GitLab API client
** `src/adapters/bitbucket.rs` - Bitbucket API client
* `src/prover/` - Prover integrations (Coq, Lean, Agda, etc.)
* `src/scheduler/` - Job queue and dispatch
* `src/db/` - Database models and queries

== Security

=== Webhook Verification

All incoming webhooks are verified:

* **GitHub** - HMAC-SHA256 signature verification
* **GitLab** - Secret token verification
* **Bitbucket** - HMAC-SHA256 signature verification

=== Code Isolation

Proof verification runs in isolated containers:

[source]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  echidnabot Server                  â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Docker Container (Coq)       â”‚  â”‚
â”‚  â”‚  â€¢ Limited memory/CPU         â”‚  â”‚
â”‚  â”‚  â€¢ Read-only filesystem       â”‚  â”‚
â”‚  â”‚  â€¢ No network access          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Docker Container (Lean)      â”‚  â”‚
â”‚  â”‚  â€¢ Isolated from Coq          â”‚  â”‚
â”‚  â”‚  â€¢ Separate resource limits   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

== License

This project is licensed under PMPL-1.0-or-later.

See link:LICENSE[LICENSE] for details.

== Contributing

Contributions welcome! Please see link:CONTRIBUTING.md[CONTRIBUTING.md] for guidelines.

== Security

For security issues, please see link:SECURITY.md[SECURITY.md].
